//#include "pch.h"
#include <iostream>
#include <time.h>
#include<stdlib.h>
#include<math.h>
using namespace std;
/*
// 1 - объединение множеств А и В
// 2 - пересечение множеств А и В
// 3 - разность множеств А и В
// 4 - разность множеств В и А
// 5 - симметрическая разность множеств А и В
// 6 - дополнение множества А
// 7 - дополнение множества А
// 8 - декартово произведение множеств А и В
// 9 - декартово произведение множеств В и А
*/

void Merge(int pwA, int pwB, int pwD, int A[], int B[], int D[]);
void Intersection(int pwA, int pwB, int pwC, int A[], int B[], int C[]);
void Diffrence(int pwA, int pwB, int pwE, int A[], int B[], int E[]);
void SymDiff(int pwA, int pwB, int pwE, int pwF, int pwG, int A[], int B[], int E[], int F[], int G[]);
void Addition(int pwB, int pwK, int pwU, int B[], int K[], int U[]);
void DecartProizv(int pwA, int pwB, int pwL, int A[], int B[], int* L[], int n[]);

int main()
{
	int n[2], ** M, ** L, * A, * B, * C, * D, * F, * E, * G, * U, * H, * Z, * K, menu, end = 0;
	int pwM = 0, pwL = 0, pwK = 0, pwH = 0, pwF = 0, pwE = 0;
	int pwG = 0, pwA, pwB, pwC = 0, pwD = 0, pwU = 101;
	setlocale(LC_ALL, "Russian");
	srand(time(NULL));

	cout << "Введите размерность множества A - ";							//предложение пользователю ввести мощность множества А
	cin >> pwA;																//ввод пользователем мощности А
	cout << "Введите размерность множества B - ";							//предложение пользователю ввести мощность множества В
	cin >> pwB;																//ввод пользователем мощности В

	A = new int[pwA];														//создание пустого множества А
	B = new int[pwB];														//создание пустого множества В
	D = new int[pwA + pwB];													//создание пустого множества D
	C = new int[pwA];														//создание пустого множества C
	F = new int[pwB];														//создание пустого множества F
	E = new int[pwA];														//создание пустого множества E
	G = new int[pwA + pwB];													//создание пустого множества G
	U = new int[pwU];														//создание универсального множества U
	H = new int[pwU];														//создание пустого множества H
	Z = new int[pwU];														//создание пустого множества Z
	K = new int[pwU];														//создание пустого множества K
	L = new int* [pwA * pwB];												//создание пустого множества L
	for (int i = 1; i <= pwA * pwB; i++)
	{
		L[i] = new int[2];
	}
	M = new int* [pwA * pwB];
	for (int i = 1; i <= pwA * pwB; i++)									//создание пустого множества M
	{
		M[i] = new int[2];
	}

	cout << "Задание множеств через высказывание - 1" << endl;				//предоставление пользователю выбора (1-высказывание)
	cout << "Задание множеств перечеслительным способом - 2" << endl;		//предоставление пользователю выбора (2-пересечение)
	cin >> menu;															//выбор пользователя (число от 1 до 2)

	switch (menu)
	{
	case 2:
		cout << "Введите данные множества A " << endl;						//предложению пользователю ввести множество А вручную
		for (int j = 1; j <= pwA; j++)
		{
			cin >> A[j];													//заполнение множества A вручную
		}
		cout << "Введите данные множества B " << endl;						//предложению пользователю ввести множество В вручную
		for (int j = 1; j <= pwB; j++)
		{
			cin >> B[j];													//заполнение множества вручную
		}
		break;

	case 1:
		for (int j = 1; j <= pwA; j++)
		{
			A[j] = 2 * j * j + 2;												//заполнение множества А элементами по формуле
		}
		for (int j = 1; j <= pwB; j++)
		{
			B[j] = j * j * j;													//заполнение множества В элементами по формуле
		}
		for (int j = 1; j <= pwA; j++)
		{
			cout << A[j] << " ";											//вывод множества А на экран
		}
		cout << endl;
		for (int j = 1; j <= pwB; j++)
		{
			cout << B[j] << " ";											//вывод множества В на экран
		}
		cout << endl;
		break;
	}

	while (end != 1)
	{																		//меню
		cout << endl << endl;
		cout << "Объединение множеств  A и B - 1 " << endl;					// 1 - объединение множеств А и В	
		cout << "Пересечение множеств  A и B - 2" << endl;					// 2 - пересечение множеств А и В
		cout << "Разность множеств A и B - 3" << endl;						// 3 - разность множеств А и В
		cout << "Разность множеств B и A - 4" << endl;						// 4 - разность множеств В и А
		cout << "Симметрическая разность множеств A и B - 5" << endl;		// 5 - симметрическая разность множеств А и В
		cout << "Дополнение множества A - 6 " << endl;						// 6 - дополнение множества А
		cout << "Дополнение множества B - 7 " << endl;						// 7 - дополнение множества А
		cout << "Декартово произведение множеств A и B - 8" << endl;		// 8 - декартово произведение множеств А и В
		cout << "Декартово произведение множеств B и A - 9" << endl;		// 9 - декартово произведение множеств В и А
		cout << "Выход - 10" << endl;										// 10 - выход из программы
		cin >> menu;														//ввод пользоввателем номера операции

		switch (menu)
		{
		case 1:
			Merge(pwA, pwB, pwD, A, B, D);
			break;															//окончание операции и возврат в меню

		case 2:
			//cout << endl << endl;
			//cout << "Пересечение множеств A и B " << endl;				//наименование операции - пересечение множеств А и В (2 операция)
			//for (int i = 1; i <= pwB; i++)								//перебор всех элементов множества В по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 2)
			//	{
			//		if (B[i] == A[j])										//проверка на строгое равенство
			//		{
			//			pwC++;												//увеличение мощности множества С на единицу
			//			C[pwC] = B[i];										//запись элемента из множества В в множество С
			//		}
			//	}															//возврат к началу цикла 2
			//}																//возврат к началу цикла 1
			//for (int i = 1; i <= pwC; i++)
			//	cout << C[i] << " ";										//вывод множества С на экран
			//cout << endl;
			Intersection(pwA, pwB, pwC, A, B, C);
			break;															//окончание операции и возврат в меню

		case 3:
			cout << endl << endl;
			cout << "Разность множеств A и B" << endl;						//наименование операции - разность множеств А и В (3 операция)
			//for (int i = 1; i <= pwA; i++)									//перебор всех элементов множества А по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
			//	{
			//		if (A[i] == B[j])										//проверка элементов на строгое равенство
			//		{
			//			i++;												//взятие следующего элемента множества А
			//			j = 0;												//обнуление счетчика множества В
			//		}
			//	}															//возврат к началу цикла 2
			//	if (i <= pwA)												//выполнять до тех пор пока множество A не закончится
			//	{
			//		pwE++;													//увеличение мощности множества Е на единицу
			//		E[pwE] = A[i];											//записть элемента из множества А во множество Е
			//	}
			//}																//возврат к началу цикла 1
			//for (int i = 1; i <= pwE; i++)
			//	cout << E[i] << " ";										//вывод элементов множества Е
			//cout << endl;
			Diffrence(pwA, pwB, pwE, A, B, E);
			break;															//окончание операции и возврат в меню

		case 4:
			cout << endl << endl;
			cout << "Разность множеств B и A" << endl;						//наименование операции разность множеств В и А (4 операция)
			//for (int i = 1; i <= pwB; i++)								//перебор всех элементов множества В по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 2)
			//	{
			//		if (B[i] == A[j])										//проверка элементов на строгое равенство
			//		{
			//			i++;												//взятие следующего элемента множества В
			//			j = 0;												//обнуление счетчика множества А
			//		}
			//	}															//возврат к началу цикла 2
			//	if (i <= pwB)												//выполнять до тех пор пока множество B не закончится
			//	{
			//		pwF++;													//увеличение мощности множества F на единицу
			//		F[pwF] = B[i];											//запись элемента из множества B во множество F
			//	}
			//}																//возврат к началу цикла 1
			//for (int i = 1; i <= pwF; i++)
			//	cout << F[i] << " ";										//вывод элементов множества F 
			//cout << endl;
			Diffrence(pwB, pwA, pwE, B, A, E);
			break;															//окончание операции и возврат в меню

		case 5:
			//cout << endl << endl;
			//cout << "Симметрическая разность множеств A и B" << endl;		//наименование операции симметрическая разность множеств А и В (5 операция)
			//pwE = 0;														//обнуление мощности множества Е
			//pwF = 0;														//обнуление мощности множества F
			//for (int i = 1; i <= pwA; i++)									//перебор всех элементов множества А по порядку (начало цикла 1)			
			//{
			//	for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
			//	{
			//		if (A[i] == B[j])										//проверка элементов на строгое равенство
			//		{
			//			i++;												//взятие следующего элемента множества А
			//			j = 0;												//обнуление счетчика множества В
			//		}
			//	}															//возврат к началу цикла 2
			//	if (i <= pwA)												//выполнять до тех пор пока множество A не закончится
			//	{
			//		pwE++;													//увеличение мощности множества F на единицу
			//		E[pwE] = A[i];											//записть элемента из множества А во множество Е
			//	}
			//}																//возврат к началу цикла 1
			//for (int i = 1; i <= pwB; i++)									//перебор всех элементов множества B по порядку (начало цикла 3)
			//{
			//	for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 4)
			//	{
			//		if (B[i] == A[j])										//проверка элементов на строгое равенство
			//		{
			//			i++;												//взятие следующего элемента множества В
			//			j = 0;												//обнуление счетчика множества А
			//		}
			//	}															//возврат к началу цикла 4
			//	if (i <= pwB)												//выполнять до тех пор пока множество B не закончится
			//	{
			//		pwF++;													//увеличение мощности множества F на единицу
			//		F[pwF] = B[i];											//запись элемента из множества B во множество F
			//	}
			//}																//возврат к началу цикла 3
			//for (int i = 1; i <= pwE; i++)
			//{
			//	G[pwG] = E[i];												//запись i-го элемента множества Е во множество G 
			//	pwG++;														//увеличение мощности множества G на единицу
			//}
			//for (int i = 1; i <= pwF; i++)
			//{
			//	G[pwG] = F[i];												//запись i-го элемента множества F во множество G 
			//	pwG++;														//увеличение мощности множества G на единицу
			//}
			//for (int i = 0; i < pwG; i++)
			//	cout << G[i] << " ";										//вывод элементов множества G
			//cout << endl;
			SymDiff(pwA, pwB, pwE, pwF, pwG, A, B, E, F, G);
			break;															//окончание операции и возврат в меню

		case 6:
			//cout << endl << endl;
			//cout << "Универсальное множества U" << endl;					//наименование операции - работа с универсумом и множеством А (6 операция)
			//for (int x = 1; x <= pwU; x++)
			//	U[x] = x;													//заполнение множества U элементами от 1 до 101
			//for (int i = 1; i <= pwU; i++)
			//	cout << U[i] << " ";										//вывод множества U
			//cout << endl;
			//for (int i = 1; i <= pwU; i++)									//перебор всех элементов множества U по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 2)
			//	{
			//		if (U[i] == A[j])										//проверка элементов на строгое равенство
			//		{
			//			i++;												//взятие следующего элемента множества U
			//			j = 0;												//обнуление счетчика множества А 
			//		}
			//	}															//возврат к началу цикла 2
			//	if (i <= pwU)												//выполнение до тех пор, пока универсум U не закончится
			//	{
			//		pwH++;													//увеличение мощности множества Н на единицу
			//		H[pwH] = U[i];											//запись элемента из универсального множества U во множество H
			//	}
			//}																//возврат к началу цикла 1
			//cout << "Дополнение множества A" << endl;						//наименование операции
			//for (int i = 1; i <= pwH; i++)
			//	cout << H[i] << " ";										//вывод элементов множества H
			//cout << endl;
			Addition(pwA, pwH, pwU, A, H, U);
			break;															//окончание операции и возврат в меню

		case 7:
			//cout << endl << endl;
			//cout << "Универсальное множества U" << endl;					//наименование операции - работа с универсумом и множеством В (7 операция)
			//for (int x = 1; x <= pwU; x++)
			//	U[x] = x;													//заполнение множества U элементами от 1 до 101
			//for (int i = 1; i <= pwU; i++)
			//	cout << U[i] << " ";										//вывод множества U
			//cout << endl;
			//for (int i = 1; i <= pwU; i++)									//перебор всех элементов множества U по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
			//	{
			//		if (U[i] == B[j])										//проверка элементов на строгое равенство
			//		{
			//			i++;												//взятие следующего элемента множества U
			//			j = 0;												//обнуление счетчика множества B
			//		}
			//	}															//возврат к началу цикла 2
			//	if (i <= pwU)												//выполнение до тех пор, пока универсум U не закончится
			//	{
			//		pwK++;													//увеличение мощности множества K на единицу
			//		K[pwK] = U[i];											//запись элемента из универсального множества U во множество K
			//	}
			//}
			//cout << "Дополнение множества B" << endl;						//наименование операции
			//for (int i = 1; i <= pwK; i++)
			//	cout << K[i] << " ";										//вывод множества К
			//cout << endl;
			Addition(pwB, pwK, pwU, B, K, U);
			break;															//окончание операции и возврат в меню

		case 8:
			//cout << endl << endl;
			//cout << "Декартово произведение множеств A и B" << endl;		//наименование операции - декартово произведение множеств А и В (8 операция)
			//for (int i = 1; i <= pwA; i++)									//перебор всех элементов множества А по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
			//	{
			//		n[1] = A[i];											//присвоение первому элементу пары значения i-го множества А (буфер1)
			//		n[2] = B[j];											//присвоение второму элементу пары значения j-го множества B (буфер2)
			//		pwL++;													//увеличение мощности множества L на единицу
			//		L[pwL][1] = n[1];										//присвоение первому элементу кортежа множества L значения буфера1
			//		L[pwL][2] = n[2];										//присвоение второму элементу кортежа множества L значения буфера2
			//	}															//возврат к началу цикла 2
			//}																//возврат к началу цикла 1
			//for (int i = 1; i <= pwL; i++)
			//{
			//	cout << "<" << L[i][1] << " " << L[i][2] << ">" << " ";		//последовательный вывод кортежей множества L
			//}
			DecartProizv(pwA, pwB, pwL, A, B, L, n);
			break;															//окончание операции и возврат в меню

		case 9:
			//cout << endl << endl;
			//cout << "Декартово произведение множеств B и A" << endl;		//наименование операции - декартово произведение множеств А и В (9 операция)
			//for (int i = 1; i <= pwB; i++)									//перебор всех элементов множества B по порядку (начало цикла 1)
			//{
			//	for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 2)
			//	{
			//		n[1] = B[i];											//присвоение первому элементу пары значения i-го множества B
			//		n[2] = A[j];											//присвоение второму элементу пары значения j-го множества A
			//		pwM++;													//увеличение мощности множества M на единицу
			//		M[pwM][1] = n[1];										//присвоение первому элементу кортежа множества M значения буфера1
			//		M[pwM][2] = n[2];										//присвоение второму элементу кортежа множества L значения буфера2
			//	}															//возврат к началу цикла 2
			//}																//возврат к началу цикла 1
			//for (int i = 1; i <= pwM; i++)
			//{
			//	cout << "<" << M[i][1] << " " << M[i][2] << ">" << " ";		//последовательный вывод кортежей множества M
			//}
			DecartProizv(pwB, pwA, pwL, B, A, L, n);
			break;															//окончание операции и возврат в меню

		case 10:															//наименование операции - выход из программы (10 операция)
			end = 1;
			return 0;
			break;
		}
	}
}


void Merge(int pwA, int pwB, int pwD, int A[], int B[], int D[])	//объединение множеств А и В (1 операция)
{
	cout << endl << endl;
	cout << "Объединение множеств  A и B " << endl;					//наименование операции - объединение множеств А и В (1 операция)
	for (pwD = 1; pwD <= pwA; pwD++)
	{
		D[pwD] = A[pwD];											//запись элментов из множества А во множество D
	}
	pwD--;
	for (int i = 1; i <= pwB; i++)									//перебор всех элементов множества В по порядку (начало цикла 1)
	{
		for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 2)
		{
			if (B[i] == A[j])										//проверка элементов на строгое равенство
			{
				i++;												//взятие следующего элемента множества В
				j = 0;												//обнуление счетчика множества А 
			}
		}															//возврат к началу цикла 2
		if (i <= pwA)												//выполнять до тех пор, пока множество A не закончится
		{
			pwD++;													//сдвиг на шаг вправо каждый раз
			D[pwD] = B[i];											//запись элемента из множества В в множество D
		}
	}																//возврат к началу цикла 1
	for (int i = 1; i <= pwD; i++)
		cout << D[i] << " ";										//вывод множества D на экран
	cout << endl;
}


void Intersection(int pwA, int pwB, int pwC, int A[], int B[], int C[])	//пересечение множеств А и В (2 операция)
{
	cout << endl << endl;
	cout << "Пересечение множеств A и B " << endl;					//наименование операции - пересечение множеств А и В (2 операция)
	for (int i = 1; i <= pwB; i++)									//перебор всех элементов множества В по порядку (начало цикла 1)
	{
		for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 2)
		{
			if (B[i] == A[j])										//проверка на строгое равенство
			{
				pwC++;												//увеличение мощности множества С на единицу
				C[pwC] = B[i];										//запись элемента из множества В в множество С
			}
		}															//возврат к началу цикла 2
	}																//возврат к началу цикла 1
	for (int i = 1; i <= pwC; i++)
		cout << C[i] << " ";										//вывод множества С на экран
	cout << endl;
}


void Diffrence(int pwA, int pwB, int pwE, int A[], int B[], int E[])//разность множеств (3 и 4 операция)
{					
	for (int i = 1; i <= pwA; i++)									//перебор всех элементов множества А по порядку (начало цикла 1)
	{
		for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
		{
			if (A[i] == B[j])										//проверка элементов на строгое равенство
			{
				i++;												//взятие следующего элемента множества А
				j = 0;												//обнуление счетчика множества В
			}
		}															//возврат к началу цикла 2
		if (i <= pwA)												//выполнять до тех пор пока множество A не закончится
		{
			pwE++;													//увеличение мощности множества Е на единицу
			E[pwE] = A[i];											//записть элемента из множества А во множество Е

		}
	}																//возврат к началу цикла 1
	for (int i = 1; i <= pwE; i++)
		cout << E[i] << " ";										//вывод элементов множества Е
	cout << endl;
}


void SymDiff(int pwA, int pwB, int pwE, int pwF, int pwG, int A[], int B[], int E[], int F[], int G[])//симметрическая разность множеств А и В (5 операция)
{
	cout << endl << endl;
	cout << "Симметрическая разность множеств A и B" << endl;		//наименование операции симметрическая разность множеств А и В (5 операция)
	pwE = 0;														//обнуление мощности множества Е
	pwF = 0;														//обнуление мощности множества F
	for (int i = 1; i <= pwA; i++)									//перебор всех элементов множества А по порядку (начало цикла 1)			
	{
		for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
		{
			if (A[i] == B[j])										//проверка элементов на строгое равенство
			{
				i++;												//взятие следующего элемента множества А
				j = 0;												//обнуление счетчика множества В
			}
		}															//возврат к началу цикла 2
		if (i <= pwA)												//выполнять до тех пор пока множество A не закончится
		{
			pwE++;													//увеличение мощности множества F на единицу
			E[pwE] = A[i];											//записть элемента из множества А во множество Е
		}
	}																//возврат к началу цикла 1
	for (int i = 1; i <= pwB; i++)									//перебор всех элементов множества B по порядку (начало цикла 3)
	{
		for (int j = 1; j <= pwA; j++)								//перебор всех элементов множества А по порядку (начало цикла 4)
		{
			if (B[i] == A[j])										//проверка элементов на строгое равенство
			{
				i++;												//взятие следующего элемента множества В
				j = 0;												//обнуление счетчика множества А
			}
		}															//возврат к началу цикла 4
		if (i <= pwB)												//выполнять до тех пор пока множество B не закончится
		{
			pwF++;													//увеличение мощности множества F на единицу
			F[pwF] = B[i];											//запись элемента из множества B во множество F
		}
	}																//возврат к началу цикла 3
	for (int i = 1; i <= pwE; i++)
	{
		G[pwG] = E[i];												//запись i-го элемента множества Е во множество G 
		pwG++;														//увеличение мощности множества G на единицу
	}
	for (int i = 1; i <= pwF; i++)
	{
		G[pwG] = F[i];												//запись i-го элемента множества F во множество G 
		pwG++;														//увеличение мощности множества G на единицу
	}
	for (int i = 0; i < pwG; i++)
		cout << G[i] << " ";										//вывод элементов множества G
	cout << endl;
}


void Addition(int pwB, int pwK, int pwU, int B[], int K[], int U[])
{
	cout << endl << endl;
	cout << "Универсальное множества U" << endl;					//наименование операции - работа с универсумом и множеством В (7 операция)
	for (int x = 1; x <= pwU; x++)
		U[x] = x;													//заполнение множества U элементами от 1 до 101
	for (int i = 1; i <= pwU; i++)
		cout << U[i] << " ";										//вывод множества U
	cout << endl;
	for (int i = 1; i <= pwU; i++)									//перебор всех элементов множества U по порядку (начало цикла 1)
	{
		for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
		{
			if (U[i] == B[j])										//проверка элементов на строгое равенство
			{
				i++;												//взятие следующего элемента множества U
				j = 0;												//обнуление счетчика множества B
			}
		}															//возврат к началу цикла 2
		if (i <= pwU)												//выполнение до тех пор, пока универсум U не закончится
		{
			pwK++;													//увеличение мощности множества K на единицу
			K[pwK] = U[i];											//запись элемента из универсального множества U во множество K
		}
	}
	cout << "Дополнение множества B" << endl;						//наименование операции
	for (int i = 1; i <= pwK; i++)
		cout << K[i] << " ";										//вывод множества К
	cout << endl;
}


void DecartProizv(int pwA, int pwB, int pwL, int A[], int B[], int* L[], int n[])
{
	cout << endl << endl;
	cout << "Декартово произведение множеств A и B" << endl;		//наименование операции - декартово произведение множеств А и В (8 операция)
	for (int i = 1; i <= pwA; i++)									//перебор всех элементов множества А по порядку (начало цикла 1)
	{
		for (int j = 1; j <= pwB; j++)								//перебор всех элементов множества В по порядку (начало цикла 2)
		{
			n[1] = A[i];											//присвоение первому элементу пары значения i-го множества А (буфер1)
			n[2] = B[j];											//присвоение второму элементу пары значения j-го множества B (буфер2)
			pwL++;													//увеличение мощности множества L на единицу
			L[pwL][1] = n[1];										//присвоение первому элементу кортежа множества L значения буфера1
			L[pwL][2] = n[2];										//присвоение второму элементу кортежа множества L значения буфера2
		}															//возврат к началу цикла 2
	}																//возврат к началу цикла 1
	for (int i = 1; i <= pwL; i++)
	{
		cout << "<" << L[i][1] << " " << L[i][2] << ">" << " ";		//последовательный вывод кортежей множества L
	}
}